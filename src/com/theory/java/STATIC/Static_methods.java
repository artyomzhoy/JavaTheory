package com.theory.java.STATIC;

@1.Статические методы

/**
 * Кроме статических переменных, в классах могут быть и статические методы.
 *
 * <p>Обычные методы привязаны к объектам (экземплярам) класса и могут обращаться к обычным-переменным класса
 * (а также к статическим переменным и методам).
 *
 * <p>Статические же методы привязаны к статическому объекту класса и
 * могут обращаться только к статическим переменным и/или другим статическим методам класса.
 *
 * <p>Чтобы вызвать обычный метод у класса, сначала нужно создать объект этого класса, а только потом вызвать метод у объекта.
 * <p>Вызвать обычный метод не у объекта, а у класса нельзя.
 */

public class Static_methods {
    public static void main(String[] args) {
        DataInfo dataInfo = new DataInfo(); // Создали объект класса DataInfo.
        System.out.println(DataInfo.getValue()); // Вызвать нестатический метод у класса нельзя!
        System.out.println(dataInfo.getValue()); // Теперь можно, после создания объекта класса DataInfo!
    }
}

class DataInfo {

    public int getValue() {

        return 100;

    }
}

    /**
     * А чтобы вызвать статический метод, достаточно чтобы просто существовал статический объект класса
     * (который всегда существует после загрузки класса в память).
     * <p>Именно поэтому метод main() — статический.
     * <p>Он привязан к статистическому объекту класса, для его вызова не нужно создавать никакие объекты.
     *
     * <p>Чтобы объявить метод статическим, нужно перед заголовком метода написать ключевое слово static.
     * <p>Общий вид этой конструкции такой:
     */

    static тип имя(параметры) {
        КОД МЕТОДА
    }

    /**
     * Чтобы вызвать статический метод из другого класса, нужно указать имя класса перед именем статического метода.
     * <p>Общий вид этой конструкции такой:
     */

    Тип имя = ИмяКласса.имяМетода(параметры);

public class Solution {

    public static void main(String args[]) { // Метод main вызывается Java-машиной командой вида: Solution.main();

        test();

    }

    public static void test() { // Статический метод test() вызывается в статическом методе main().

        int d = 10 / 2;
        int a = 100;
        int x = Math.min(d, a); // Вызываем статический метод min из класса Math.
        System.out.println(d);
        System.out.println(x);

    }
}

@2.Статические vs Обычные методы

/** <p>Обычный метод имеет привязку к объекту — экземпляру класса, статический же метод такой привязки не имеет.
 <p>Обычный метод может обращаться к переменным в своем экземпляре класса, статический — нет:
 у него просто нет никакого экземпляра класса, связанного с ним.

 <p>Отличия двух типов методов:

 <p>1. Есть связь с экземпляром класса.
 <p> При вызове обычного метода в него передается скрытый параметр — объект, у которого его вызывали.
 Этот параметр имеет имя this.
 Именно этот скрытый параметр — ссылка на объект, у которого вызвали метод — и отличает обычные методы от статических.
 <p>У статических методов такого скрытого параметра нет,
 поэтому внутри статических методов нельзя пользоваться ключевым словом this,
 и из статического метода нельзя вызвать нестатический: ссылку на экземпляр класса попросту неоткуда взять.

 <p>2. Может вызывать обычные методы класса.
 <p>В обычном методе класса всегда есть скрытый параметр — this — ссылка на объект класса, у которого был вызван метод.
 Каждый раз, когда вы вызываете обычный метод внутри другого обычного метода, для этого вызова используется скрытый параметр this.
 <p>Пример:*/

class Min {
    int min(int a, int b) {
        return a < b ? a : b;
    }

    int min(int a, int b, int c) {
        int t = this.min(a, b);
        return this.min(t, c);
    }
}

/** <p>3. Может вызывать статические методы класса.
 <p>Статические методы можно вызывать откуда угодно — из любого места программы.
 А значит, их можно вызывать и из статических методов, и из обычных. Никаких ограничений тут нет.

 <p>4. Может обращаться к обычным переменным класса.
 <p>Из обычного метода можно обращаться к обычным переменным класса,
 т.к. при этом произойдет обращение к переменным экземпляра класса, который легко получить из скрытого параметра this.
 <p>Статический метод не знает, из какого экземпляра класса ему брать значения обычных переменных.
 У нас вообще легко может быть ситуация, когда статический метод вызван,
 а ни одного экземпляра класса еще создано в программе не было.
 <p>Поэтому статические методы не могут обращаться к обычным переменным класса.

 <p>5. Может обращаться к статическим переменным класса.
 <p> Ситуация с обращением к статическим переменным такая же, как и с обращениями к статическим методам.
 К статическим переменным можно обращаться из любого места в программе. А значит, можно обращаться из статических и обычных методов.

 <p>6. Может быть вызван у объекта.
 <p>И статические, и обычные методы можно вызывать у объекта. Обычный метод можно, потому что только у объекта его вызвать и можно.
 Статический метод тоже можно вызывать у объекта:
 при этом компилятор сам определит тип переменной и вызовет статический метод по ее типу.*/

Integer i = 1;
    int x = i.parseInt("12");

Как это видит компилятор

Integer i = 1;
    int x = Integer.parseInt("12");

/** <p>7. Может быть вызван у класса.
 <p>У класса можно вызвать только статический метод, для вызова обычного метода нужна ссылка на экземпляр класса.
 Поэтому нельзя вызвать обычный метод конструкцией вида:*/

ИмяКласса.имяМетода(параметры);




